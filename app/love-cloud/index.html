<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>äº‘æœµå˜å˜å˜ Â· æ¶‚é¸¦æ¿</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; padding: 10px; background: #f0f8ff; }
    .container { max-width: 480px; margin: 0 auto; background: #fff; border-radius: 12px; box-shadow: 0 2px 12px #ddd; padding: 14px; }
    h1 { text-align: center; color: #1e90ff; font-size: 24px; margin: 0 0 16px 0; }
    .toolbar { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 10px; }
    .btn { padding: 8px 16px; border: none; border-radius: 6px; background: #1e90ff; color: #fff; cursor: pointer; font-size: 15px; }
    .btn:disabled { opacity: 0.5; }
    .btn.outline { background: #fff; color: #1e90ff; border: 1px solid #1e90ff; }
    .color-btn { width: 28px; height: 28px; border-radius: 50%; border: 2px solid #fff; cursor: pointer; box-shadow: 0 0 0 1px #ccc; }
    .color-btn.selected { box-shadow: 0 0 0 2px #1e90ff; }
    .tool-btn { width: 32px; height: 32px; border-radius: 6px; border: 1.5px solid #ccc; background: #fff; font-size: 18px; cursor: pointer; }
    .tool-btn.selected { background: #1e90ff; color: #fff; }
    .size-btn { width: 24px; height: 24px; border-radius: 50%; background: #eee; border: none; cursor: pointer; }
    .size-btn.selected { background: #1e90ff; }
    .canvas-area { width: 100vw; max-width: 440px; height: 400px; margin: 0 auto; position: relative; }
    canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; border-radius: 12px; background: #fff; border: 1px solid #eee; touch-action: none; }
    .toolbar-label { font-size: 13px; color: #666; margin-right: 2px; }
    input[type="file"] { display: none; }
  </style>
</head>
<body>
<div class="container">
  <h1>äº‘æœµå˜å˜å˜</h1>
  <div class="toolbar">
    <label class="btn outline">
      æ‹ç…§
      <input type="file" accept="image/*" capture="environment" id="cameraInput">
    </label>
    <label class="btn outline">
      é€‰æ‹©å›¾ç‰‡
      <input type="file" accept="image/*" id="fileInput">
    </label>
    <button class="btn" id="undoBtn" disabled>æ’¤é”€</button>
    <button class="btn" id="redoBtn" disabled>é‡åš</button>
    <button class="btn" id="saveBtn">ä¿å­˜</button>
    <button class="btn" id="clearBtn">æ¸…ç©º</button>
  </div>
  <div class="toolbar">
    <span class="toolbar-label">é¢œè‰²</span>
    <div id="colorPalette" style="display: flex; gap: 4px;"></div>
    <input type="color" id="customColor" style="width:28px;height:28px;padding:0;cursor:pointer;">
    <span class="toolbar-label">å·¥å…·</span>
    <button class="tool-btn selected" id="penBtn" title="ç”»ç¬”">âœï¸</button>
    <button class="tool-btn" id="eraserBtn" title="æ©¡çš®æ“¦">ğŸ§¹</button>
    <span class="toolbar-label">ç²—ç»†</span>
    <div id="sizeButtons" style="display: flex; gap: 2px;"></div>
  </div>
  <div class="canvas-area" style="position:relative;">
    <canvas id="bgCanvas"></canvas>
    <canvas id="drawCanvas"></canvas>
  </div>
</div>
<script>
(function() {
  // ç”»å¸ƒä¸çŠ¶æ€
  const bgCanvas = document.getElementById('bgCanvas');
  const drawCanvas = document.getElementById('drawCanvas');
  const bgCtx = bgCanvas.getContext('2d');
  const ctx = drawCanvas.getContext('2d');
  let bgImage = null;
  let currentColor = "#000000";
  let currentSize = 5;
  let currentTool = "pen";
  let isDrawing = false;
  let lastPt = null;
  let strokes = [];
  let redoStack = [];
  let currentStroke = null;

  // ç¼©æ”¾å’Œå¹³ç§»
  let scale = 1, offsetX = 0, offsetY = 0;
  let lastScale = 1, lastOffsetX = 0, lastOffsetY = 0;
  let multiTouch = false, lastTouchDist = 0, lastTouchMid = null;

  // åˆå§‹åŒ–ç”»å¸ƒ
  function resizeCanvas() {
    const ctn = document.querySelector('.canvas-area');
    const w = ctn.clientWidth, h = ctn.clientHeight;
    [bgCanvas, drawCanvas].forEach(c => {
      c.width = w; c.height = h; c.style.width = w + 'px'; c.style.height = h + 'px';
    });
    renderBg();
    redrawStrokes();
  }
  window.addEventListener('resize', resizeCanvas);

  // é¢œè‰²æ¡
  const paletteColors = [
    '#FFB6C1', '#FFFACD', '#87CEFA', '#AEEEEE', '#E6E6FA', '#FFD580', '#fffbe7', '#222'
  ];
  function buildColorPalette() {
    const colorPalette = document.getElementById('colorPalette');
    colorPalette.innerHTML = "";
    paletteColors.forEach((color, i) => {
      const btn = document.createElement('button');
      btn.className = 'color-btn' + (color === currentColor ? ' selected' : '');
      btn.style.backgroundColor = color;
      btn.onclick = function() { selectColor(color, false); };
      colorPalette.appendChild(btn);
    });
    // è‡ªå®šä¹‰é¢œè‰²
    const customColorInput = document.getElementById('customColor');
    customColorInput.value = currentColor;
    customColorInput.onchange = function(e) { selectColor(e.target.value, true); };
  }
  function selectColor(color, custom) {
    currentColor = color;
    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
    if (!custom) {
      let idx = paletteColors.indexOf(color);
      if (idx !== -1) document.getElementById('colorPalette').children[idx].classList.add('selected');
    }
  }
  buildColorPalette();

  // ç²—ç»†
  const sizes = [2, 5, 9, 16];
  function buildSizeButtons() {
    const sizeButtons = document.getElementById('sizeButtons');
    sizeButtons.innerHTML = "";
    sizes.forEach(size => {
      const btn = document.createElement('button');
      btn.className = 'size-btn' + (size === currentSize ? ' selected' : '');
      btn.innerHTML = `<span style="display:inline-block;width:${size}px;height:${size}px;background:currentColor;border-radius:50%;"></span>`;
      btn.onclick = function() {
        currentSize = size;
        document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
      };
      sizeButtons.appendChild(btn);
    });
  }
  buildSizeButtons();

  // å·¥å…·æ 
  document.getElementById('penBtn').onclick = function() {
    currentTool = 'pen';
    this.classList.add('selected');
    document.getElementById('eraserBtn').classList.remove('selected');
  };
  document.getElementById('eraserBtn').onclick = function() {
    currentTool = 'eraser';
    this.classList.add('selected');
    document.getElementById('penBtn').classList.remove('selected');
  };

  // æ–‡ä»¶è¾“å…¥
  document.getElementById('fileInput').onchange =
  document.getElementById('cameraInput').onchange = function(e) {
    if (e.target.files && e.target.files[0]) {
      const reader = new FileReader();
      reader.onload = function(ev) {
        bgImage = new window.Image();
        bgImage.onload = function() { renderBg(); };
        bgImage.src = ev.target.result;
      };
      reader.readAsDataURL(e.target.files[0]);
    }
  };

  // æ¸²æŸ“åº•å›¾
  function renderBg() {
    bgCtx.clearRect(0,0,bgCanvas.width, bgCanvas.height);
    if (bgImage) {
      const scale = Math.min(bgCanvas.width / bgImage.width, bgCanvas.height / bgImage.height);
      const w = bgImage.width * scale, h = bgImage.height * scale;
      const x = (bgCanvas.width - w) / 2, y = (bgCanvas.height - h) / 2;
      bgCtx.drawImage(bgImage, x, y, w, h);
    } else {
      bgCtx.fillStyle = '#fff';
      bgCtx.fillRect(0,0,bgCanvas.width, bgCanvas.height);
    }
  }

  // ç»˜åˆ¶æ‰€æœ‰ç¬”ç”»
  function redrawStrokes() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
    strokes.forEach(drawStroke);
    ctx.setTransform(1,0,0,1,0,0);
  }
  function drawStroke(stroke) {
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = stroke.tool === 'eraser' ? 'destination-out' : 'source-over';
    ctx.strokeStyle = stroke.tool === 'eraser' ? '#fff' : stroke.color;
    ctx.lineWidth = stroke.size;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(stroke.points[0][0], stroke.points[0][1]);
    for(let i=1;i<stroke.points.length;i++) ctx.lineTo(stroke.points[i][0], stroke.points[i][1]);
    ctx.stroke();
    ctx.restore();
  }

  // æ’¤é”€/é‡åš
  document.getElementById('undoBtn').onclick = function() {
    if (strokes.length) {
      redoStack.push(strokes.pop());
      redrawStrokes();
      updateUndoRedo();
    }
  };
  document.getElementById('redoBtn').onclick = function() {
    if (redoStack.length) {
      strokes.push(redoStack.pop());
      redrawStrokes();
      updateUndoRedo();
    }
  };
  function updateUndoRedo() {
    document.getElementById('undoBtn').disabled = strokes.length === 0;
    document.getElementById('redoBtn').disabled = redoStack.length === 0;
  }

  // æ¸…ç©º
  document.getElementById('clearBtn').onclick = function() {
    strokes = [];
    redoStack = [];
    redrawStrokes();
    updateUndoRedo();
  };

  // ä¿å­˜
  document.getElementById('saveBtn').onclick = function() {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = bgCanvas.width;
    tempCanvas.height = bgCanvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(bgCanvas, 0, 0);
    tempCtx.drawImage(drawCanvas, 0, 0);
    const link = document.createElement('a');
    link.download = "äº‘æœµæ¶‚é¸¦.png";
    link.href = tempCanvas.toDataURL("image/png");
    link.click();
  };

  // äº‹ä»¶ï¼šç»˜ç”»ä¸ç¼©æ”¾
  function getPt(e) {
    const rect = drawCanvas.getBoundingClientRect();
    if (e.touches) {
      return [(e.touches[0].clientX-rect.left-offsetX)/scale, (e.touches[0].clientY-rect.top-offsetY)/scale];
    }
    return [(e.clientX-rect.left-offsetX)/scale, (e.clientY-rect.top-offsetY)/scale];
  }
  function getTouchDist(e) {
    if (e.touches.length < 2) return 0;
    let dx = e.touches[1].clientX - e.touches[0].clientX;
    let dy = e.touches[1].clientY - e.touches[0].clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }
  function getTouchMid(e) {
    if (e.touches.length < 2) return [0,0];
    return [
      (e.touches[0].clientX + e.touches[1].clientX)/2,
      (e.touches[0].clientY + e.touches[1].clientY)/2
    ];
  }

  drawCanvas.addEventListener('touchstart', function(e) {
    if (e.touches.length === 2) {
      multiTouch = true; isDrawing = false;
      lastScale = scale; lastOffsetX = offsetX; lastOffsetY = offsetY;
      lastTouchDist = getTouchDist(e);
      lastTouchMid = getTouchMid(e);
    } else if (e.touches.length === 1 && !multiTouch) {
      isDrawing = true;
      const [x, y] = getPt(e);
      lastPt = [x, y];
      currentStroke = { tool: currentTool, color: currentColor, size: currentSize, points: [[x, y]] };
    }
  }, {passive:false});
  drawCanvas.addEventListener('touchmove', function(e) {
    if (e.touches.length === 2) {
      let dist = getTouchDist(e);
      let mid = getTouchMid(e);
      let ds = dist / lastTouchDist;
      scale = Math.max(0.5, Math.min(5, lastScale * ds));
      offsetX = lastOffsetX + (mid[0]-lastTouchMid[0]);
      offsetY = lastOffsetY + (mid[1]-lastTouchMid[1]);
      redrawStrokes();
      e.preventDefault();
    } else if (e.touches.length === 1 && isDrawing && !multiTouch) {
      const [x, y] = getPt(e);
      currentStroke.points.push([x, y]);
      redrawStrokes();
      // åªç”»å½“å‰çº¿æ®µ
      ctx.save();
      ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
      ctx.globalCompositeOperation = currentTool==='eraser'?'destination-out':'source-over';
      ctx.strokeStyle = currentTool==='pen'?currentColor:'#fff';
      ctx.lineWidth = currentSize;
      ctx.beginPath();
      ctx.moveTo(lastPt[0], lastPt[1]);
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.restore();
      lastPt = [x, y];
      e.preventDefault();
    }
  }, {passive:false});
  drawCanvas.addEventListener('touchend', function(e) {
    if (multiTouch && e.touches.length < 2) {
      multiTouch = false;
    }
    if (isDrawing && !multiTouch) {
      if (currentStroke && currentStroke.points.length > 1) {
        strokes.push(currentStroke);
        redoStack = [];
        updateUndoRedo();
      }
      isDrawing = false; currentStroke = null;
    }
  });

  // é¼ æ ‡äº‹ä»¶
  drawCanvas.addEventListener('mousedown', function(e) {
    if (multiTouch) return;
    isDrawing = true;
    const [x, y] = getPt(e);
    lastPt = [x, y];
    currentStroke = { tool: currentTool, color: currentColor, size: currentSize, points: [[x, y]] };
  });
  drawCanvas.addEventListener('mousemove', function(e) {
    if (!isDrawing || multiTouch) return;
    const [x, y] = getPt(e);
    currentStroke.points.push([x, y]);
    redrawStrokes();
    ctx.save();
    ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
   (x, y);
    ctx.stroke();
    ctx.restore();
    lastPt = [x, y];
  });
  drawCanvas.addEventListener('mouseup', function(e) {
    if (isDrawing && !multiTouch) {
      if (currentStroke && currentStroke.points.length > 1) {
        strokes.push(currentStroke);
        redoStack = [];
        updateUndoRedo();
      }
      isDrawing = false; currentStroke = null;
    }
  });
  drawCanvas.addEventListener('mouseleave', function(e) {
    isDrawing = false; currentStroke = null;
  });

  // åˆå§‹åŒ–
  resizeCanvas();
  renderBg();
  redrawStrokes();
})();
</script>
</body>
</html>