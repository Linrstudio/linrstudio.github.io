<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>äº‘æœµå˜å˜å˜ Â· é«˜çº§æ¶‚é¸¦æ¿</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { font-family: 'å¾®è½¯é›…é»‘', Arial, sans-serif; background: #f0f8ff; color: #333;}
    .container { max-width: 480px; margin: 30px auto; background: #fff; border-radius: 15px; box-shadow: 0 2px 16px #ddd; padding: 10px 0 24px 0;}
    h1 { text-align: center; color: #1e90ff;}
    .btn { display: inline-block; padding: 10px 18px; background: #1e90ff; color: #fff; border: none; border-radius: 8px; font-size: 16px; cursor: pointer;}
    .btn:active { background: #1565c0; }
    .tool-bar { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 8px; margin: 12px 0;}
    .color-btn { width: 28px; height: 28px; border-radius: 50%; border: 2px solid #fff; cursor: pointer; outline: 1.5px solid #ccc;}
    .color-btn.selected { outline: 2.5px solid #1e90ff;}
    .color-btn.custom { border: 2px dashed #aaa;}
    .tool-btn { width: 32px; height: 32px; border-radius: 8px; border: 1.5px solid #ccc; background: #f6f6f6; font-size: 18px; cursor: pointer;}
    .tool-btn.selected { background: #1e90ff; color: #fff;}
    .size-btn { width: 25px; height: 25px; border-radius: 50%; background: #eee; border: none; font-size: 16px; cursor: pointer;}
    .size-btn.selected { background: #1e90ff; color: #fff;}
    .toolbar-label { font-size: 13px; color: #666; margin: 0 5px;}
    .canvas-area { width: 100vw; max-width: 440px; height: 400px; margin: 0 auto; position: relative;}
    canvas { background: #fff; border-radius: 12px; border: 1.5px solid #eee; touch-action: none; width: 100%; height: 100%;}
    .action-bar { text-align:center; margin-top: 10px;}
    .tips { color: #777; font-size: 13px; text-align: center; margin-top: 3px;}
    .file-input { display: none;}
  </style>
</head>
<body>
<div class="container">
  <h1>äº‘æœµå˜å˜å˜ Â· é«˜çº§æ¶‚é¸¦æ¿</h1>
  <div class="tool-bar">
    <label class="btn" style="background:#fff;color:#1e90ff;border:1px solid #1e90ff;">
      æ‹ç…§
      <input type="file" accept="image/*" capture="environment" id="cameraInput" class="file-input">
    </label>
    <label class="btn" style="background:#fff;color:#1e90ff;border:1px solid #1e90ff;">
      é€‰æœ¬åœ°å›¾
      <input type="file" accept="image/*" id="localInput" class="file-input">
    </label>
    <button class="btn" onclick="clearDrawLayer()">æ¸…ç©ºç”»å¸ƒ</button>
    <button class="btn" onclick="saveCanvas()">ä¿å­˜åˆ°æœ¬åœ°</button>
    <button class="btn" onclick="undo()">æ’¤é”€</button>
    <button class="btn" onclick="redo()">é‡åš</button>
  </div>
  <div class="tool-bar">
    <span class="toolbar-label">é¢œè‰²</span>
    <div id="colorBar" style="display:flex;"></div>
    <input type="color" id="customColorPicker" style="display:none;">
    <span class="toolbar-label">ç²—ç»†</span>
    <div id="sizeBar" style="display:flex;"></div>
    <button class="tool-btn" id="penBtn" title="ç”»ç¬”">âœï¸</button>
    <button class="tool-btn" id="eraserBtn" title="æ©¡çš®æ“¦">ğŸ§¹</button>
    <button class="tool-btn" id="smudgeBtn" title="æ¶‚æŠ¹">ğŸ–Œï¸</button>
  </div>
  <div class="tips">åŒæŒ‡æåˆæ”¾å¤§/ç¼©å°ï¼Œæ‹–åŠ¨ç”»å¸ƒï¼Œå•æŒ‡ç»˜åˆ¶ã€‚æ”¯æŒæ©¡çš®æ“¦å’Œæ¶‚æŠ¹ã€‚</div>
  <div class="canvas-area" style="position:relative;">
    <canvas id="bgCanvas" width="440" height="400" style="position:absolute;left:0;top:0;z-index:0;"></canvas>
    <canvas id="drawCanvas" width="440" height="400" style="position:absolute;left:0;top:0;z-index:1;"></canvas>
  </div>
  <div class="action-bar"></div>
</div>
<script>
  // é¢œè‰²ã€ç²—ç»†
  const cuteColors = [
    {name: "æ¡ƒç²‰", val: "#FFB6C1"},
    {name: "æŸ æª¬é»„", val: "#FFFACD"},
    {name: "å¤©è“", val: "#87CEFA"},
    {name: "è–„è·ç»¿", val: "#AEEEEE"},
    {name: "è–°è¡£è‰ç´«", val: "#E6E6FA"},
    {name: "äº®æ©™", val: "#FFD580"},
    {name: "å¥¶æ²¹ç™½", val: "#fffbe7"},
    {name: "é»‘", val: "#222"},
    {name: "è‡ªå®šä¹‰", val: "#ff69b4", custom: true}
  ];
  const cuteSizes = [
    {name: "ç»†", val: 2},
    {name: "ä¸­", val: 5},
    {name: "ç²—", val: 10},
    {name: "è¶…ç²—", val: 20}
  ];

  let selectedColor = cuteColors[0].val;
  let selectedSize = cuteSizes[1].val;
  let tool = 'pen'; // pen, eraser, smudge

  // ç”»å¸ƒå’Œå˜æ¢
  const bgCanvas = document.getElementById('bgCanvas');
  const bgCtx = bgCanvas.getContext('2d');
  const canvas = document.getElementById('drawCanvas');
  const ctx = canvas.getContext('2d');
  let bgImage = null; // åº•å›¾
  let canvasW = canvas.width, canvasH = canvas.height;

  // å˜æ¢å‚æ•°
  let scale = 1, offsetX = 0, offsetY = 0;
  let lastScale = 1, lastOffsetX = 0, lastOffsetY = 0;
  let isDrawing = false, lastPt = null;
  let isPanning = false, lastPan = null;
  let lastTouchDist = 0, lastTouchMid = null;
  let drawingHist = [], redoHist = [];

  // --- å·¥å…·æ  ---
  function setupColorBar() {
    const colorBar = document.getElementById('colorBar');
    colorBar.innerHTML = "";
    cuteColors.forEach((c, i) => {
      const btn = document.createElement('button');
      btn.className = "color-btn" + (i === 0 ? " selected" : "") + (c.custom ? " custom" : "");
      btn.style.background = c.val;
      btn.title = c.name;
      btn.onclick = () => {
        if (c.custom) {
          document.getElementById('customColorPicker').click();
        } else {
          selectedColor = c.val;
          document.querySelectorAll('.color-btn').forEach(x=>x.classList.remove('selected'));
          btn.classList.add('selected');
        }
      };
      colorBar.appendChild(btn);
    });
  }
  function setupSizeBar() {
    const sizeBar = document.getElementById('sizeBar');
    sizeBar.innerHTML = "";
    cuteSizes.forEach((s, i) => {
      const btn = document.createElement('button');
      btn.className = "size-btn" + (i === 1 ? " selected" : "");
      btn.innerHTML = `<span style="display:inline-block;width:${s.val}px;height:${s.val}px;background:${selectedColor};border-radius:50%;"></span>`;
      btn.title = s.name;
      btn.onclick = () => {
        selectedSize = s.val;
        document.querySelectorAll('.size-btn').forEach(x=>x.classList.remove('selected'));
        btn.classList.add('selected');
      };
      sizeBar.appendChild(btn);
    });
  }
  setupColorBar();
  setupSizeBar();

  // è‡ªå®šä¹‰é¢œè‰²
  document.getElementById('customColorPicker').addEventListener('change',function(e){
    selectedColor = e.target.value;
    // åŠ¨æ€æ›´æ–°è‡ªå®šä¹‰æŒ‰é’®é¢œè‰²
    let btns = document.querySelectorAll('.color-btn.custom');
    btns.forEach(btn=>btn.style.background=selectedColor);
    document.querySelectorAll('.color-btn').forEach(x=>x.classList.remove('selected'));
    btns[0].classList.add('selected');
  });

  // å·¥å…·é€‰æ‹©
  const penBtn = document.getElementById('penBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  const smudgeBtn = document.getElementById('smudgeBtn');
  function selectTool(t) {
    tool = t;
    penBtn.classList.toggle('selected', t==='pen');
    eraserBtn.classList.toggle('selected', t==='eraser');
    smudgeBtn.classList.toggle('selected', t==='smudge');
  }
  penBtn.onclick = ()=>selectTool('pen');
  eraserBtn.onclick = ()=>selectTool('eraser');
  smudgeBtn.onclick = ()=>selectTool('smudge');
  selectTool('pen');

  // --- å›¾ç‰‡å¯¼å…¥ ---
  function setBgImage(src) {
    bgImage = new window.Image();
    bgImage.onload = function() {
      drawBg();
    }
    bgImage.src = src;
  }
  document.getElementById('cameraInput').addEventListener('change', function(e){
    if (e.target.files[0]) {
      const url = URL.createObjectURL(e.target.files[0]);
      setBgImage(url);
    }
  });
  document.getElementById('localInput').addEventListener('change', function(e){
    if (e.target.files[0]) {
      const url = URL.createObjectURL(e.target.files[0]);
      setBgImage(url);
    }
  });

  function drawBg() {
    bgCtx.setTransform(1,0,0,1,0,0);
    bgCtx.clearRect(0,0,canvasW,canvasH);
    if (bgImage) {
      let s = Math.min(canvasW/bgImage.width, canvasH/bgImage.height), w = bgImage.width*s, h = bgImage.height*s;
      bgCtx.drawImage(bgImage, (canvasW-w)/2, (canvasH-h)/2, w, h);
    } else {
      bgCtx.fillStyle="#fff"; bgCtx.fillRect(0,0,canvasW,canvasH);
    }
  }

  // --- ç»˜åˆ¶æµç¨‹ ---
  function drawAll() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvasW,canvasH);
    ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
    drawingHist.forEach(d=>{
      ctx.save();
      ctx.globalAlpha = d.tool==='smudge'?0.7:1;
      if (d.tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
      } else if (d.tool === 'smudge') {
        ctx.globalCompositeOperation = 'source-over';
      } else {
        ctx.globalCompositeOperation = 'source-over';
      }
      ctx.strokeStyle = d.color;
      ctx.lineWidth = d.size;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.beginPath();
      ctx.moveTo(d.points[0][0], d.points[0][1]);
      for(let i=1;i<d.points.length;i++) ctx.lineTo(d.points[i][0], d.points[i][1]);
      ctx.stroke();
      ctx.restore();
    });
    ctx.setTransform(1,0,0,1,0,0);
  }
  function addStroke(pts, color, size, tool) {
    drawingHist.push({points:[...pts], color, size, tool});
    redoHist = []; // æ–°ç»˜åˆ¶æ¸…ç©ºé‡åšå †æ ˆ
    drawAll();
  }
  function clearDrawLayer() {
    drawingHist = []; redoHist = [];
    drawAll();
  }
  function saveCanvas() {
    // åˆæˆåº•å›¾+ç»˜å›¾å±‚
    let outCanvas = document.createElement('canvas');
    outCanvas.width = canvasW; outCanvas.height = canvasH;
    let outCtx = outCanvas.getContext('2d');
    // èƒŒæ™¯
    if (bgImage) {
      let s = Math.min(canvasW/bgImage.width, canvasH/bgImage.height), w = bgImage.width*s, h = bgImage.height*s;
      outCtx.drawImage(bgImage, (canvasW-w)/2, (canvasH-h)/2, w, h);
    } else {
      outCtx.fillStyle="#fff"; outCtx.fillRect(0,0,canvasW,canvasH);
    }
    // ç»˜å›¾å†…å®¹
    drawingHist.forEach(d=>{
      outCtx.save();
      outCtx.globalAlpha = d.tool==='smudge'?0.7:1;
      if (d.tool === 'eraser') {
        outCtx.globalCompositeOperation = 'destination-out';
     [0][1]);
      for(let i=1;i<d.points.length;i++) outCtx.lineTo(d.points[i][0], d.points[i][1]);
      outCtx.stroke();
      outCtx.restore();
    });
    // ä¿å­˜
    const url = outCanvas.toDataURL("image/png");
    const link = document.createElement('a');
    link.download = "äº‘æœµæ¶‚é¸¦.png";
    link.href = url;
    link.click();
  }

  // æ’¤é”€/é‡åšåŠŸèƒ½
  function undo() {
    if (drawingHist.length>0) {
      redoHist.push(drawingHist.pop());
      drawAll();
    }
  }
  function redo() {
    if (redoHist.length>0) {
      drawingHist.push(redoHist.pop());
      drawAll();
    }
  }
  window.undo = undo; window.redo = redo;

  // ---- è§¦æ‘¸/é¼ æ ‡äº‹ä»¶ ----
  function getCanvasPt(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX-rect.left - offsetX)/scale;
    const y = (clientY-rect.top - offsetY)/scale;
    return [x, y];
  }
  let currStroke = [];
  let activeTouches = {};
  let isMultiTouch = false;

  // ç»Ÿä¸€Pointeräº‹ä»¶
  canvas.addEventListener('pointerdown', function(e){
    if (e.pointerType==="touch" && isMultiTouch) return; // è·³è¿‡å¤šæŒ‡
    if (e.button!==undefined && e.button!==0) return;
    if (isMultiTouch) return; // é¿å…åŒæŒ‡ç¼©æ”¾æ—¶è¯¯è§¦
    isDrawing = true;
    let pt = getCanvasPt(e.clientX, e.clientY);
    currStroke = [pt];
    lastPt = pt;
  });
  canvas.addEventListener('pointermove', function(e){
    if (isDrawing && !isMultiTouch) {
      let pt = getCanvasPt(e.clientX, e.clientY);
      if (tool==='pen' || tool==='eraser') {
        currStroke.push(pt);
        drawAll();
        // ä¸´æ—¶ç”»å½“å‰è½¨è¿¹
        ctx.save();
        ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
        ctx.globalAlpha = tool==='eraser'?1:1;
        ctx.globalCompositeOperation = tool==='eraser'?'destination-out':'source-over';
        ctx.strokeStyle = tool==='pen'?selectedColor:"#000";
        ctx.lineWidth = selectedSize;
        ctx.beginPath();
        ctx.moveTo(lastPt[0], lastPt[1]);
        ctx.lineTo(pt[0], pt[1]);
        ctx.stroke();
        ctx.restore();
        lastPt = pt;
      } else if (tool==='smudge') {
        smudgeAt(pt[0], pt[1], selectedSize);
        currStroke.push(pt);
      }
    }
  });
  canvas.addEventListener('pointerup', function(e){
    if (isDrawing && !isMultiTouch) {
      addStroke(currStroke, tool==='pen'?selectedColor:"#000", selectedSize, tool);
    }
    isDrawing = false;
    currStroke = [];
  });
('pointerout', function(e){
    isDrawing = false;
    currStroke = [];
  });

  // ---- å¤šæŒ‡ç¼©æ”¾/å¹³ç§» ----
  let touchInfo = {};
  canvas.addEventListener('touchstart', function(e){
    if (e.touches.length===2) {
      isMultiTouch = true;
      isDrawing = false; // ç¦æ­¢ç»˜åˆ¶
      lastScale = scale;
      lastOffsetX = offsetX; lastOffsetY = offsetY;
      lastTouchDist = getTouchDist(e);
      lastTouchMid = getTouchMid(e);
    }
  }, {passive:false});
  canvas.addEventListener('touchmove', function(e){
    if (e.touches.length===2) {
      e.preventDefault();
      isMultiTouch = true;
      let currDist = getTouchDist(e);
      let currMid = getTouchMid(e();
    }
  }, {passive:false});
  canvas.addEventListener('touchend', function(e){
    if (e.touches.length<2) {
      isMultiTouch = false;
    }
  });

  function getTouchDist(e){
    let t0 = e.touches[0], t1 = e.touches[1];
    let dx = t1.clientX-t0.clientX, dy = t1.clientY-t0.clientY;
    return Math.sqrt(dx*dx+dy*dy);
  }
  function getTouchMid(e){
    let t0 = e.touches[0], t1 =[1];
    return [(t0.clientX+t1.clientX)/2, (t0.clientY+t1.clientY)/2];
  }

  // ---- ç®€å•æ¶‚æŠ¹åŠŸèƒ½ ----
  function smudgeAt(x, y, size){
    let r = Math.floor(size*2);
    let sx = Math.floor(x-r), sy = Math.floor(y-r);
    let imgData = ctx.getImageData(sx, sy, r*2, r*2);
    let d = imgData.data;
    for (let i=0; i<d.length; i+=4){
      let sumR=0,sumG=0,sumB=0,count=0;
      for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
        let idx = i+((dx+dy*2)*4);
        if(idx>=0 && idx<d.length){
          sumR+=d[idx]; sumG+=d[idx+1]; sumB+=d[idx+2]; count++;
        }
      }
      d[i] = sumR/count; d[i+1], sx, sy);
  }

  // --- åˆå§‹åŒ– ---
  bgCtx.fillStyle="#fff"; bgCtx.fillRect(0,0,canvasW,canvasH);
  drawBg();
  drawAll();
</script>
</body>
</html>